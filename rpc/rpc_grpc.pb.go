// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.6
// source: rpc/rpc.proto

package rpc

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CNIBackend_AddNetwork_FullMethodName           = "/rpc.CNIBackend/AddNetwork"
	CNIBackend_DelNetwork_FullMethodName           = "/rpc.CNIBackend/DelNetwork"
	CNIBackend_GetAllocatableValues_FullMethodName = "/rpc.CNIBackend/GetAllocatableValues"
)

// CNIBackendClient is the client API for CNIBackend service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The service definition.
type CNIBackendClient interface {
	AddNetwork(ctx context.Context, in *AddNetworkRequest, opts ...grpc.CallOption) (*AddNetworkReply, error)
	DelNetwork(ctx context.Context, in *DelNetworkRequest, opts ...grpc.CallOption) (*DelNetworkReply, error)
	GetAllocatableValues(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllocatableValuesReply, error)
}

type cNIBackendClient struct {
	cc grpc.ClientConnInterface
}

func NewCNIBackendClient(cc grpc.ClientConnInterface) CNIBackendClient {
	return &cNIBackendClient{cc}
}

func (c *cNIBackendClient) AddNetwork(ctx context.Context, in *AddNetworkRequest, opts ...grpc.CallOption) (*AddNetworkReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddNetworkReply)
	err := c.cc.Invoke(ctx, CNIBackend_AddNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cNIBackendClient) DelNetwork(ctx context.Context, in *DelNetworkRequest, opts ...grpc.CallOption) (*DelNetworkReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DelNetworkReply)
	err := c.cc.Invoke(ctx, CNIBackend_DelNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cNIBackendClient) GetAllocatableValues(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllocatableValuesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllocatableValuesReply)
	err := c.cc.Invoke(ctx, CNIBackend_GetAllocatableValues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CNIBackendServer is the server API for CNIBackend service.
// All implementations must embed UnimplementedCNIBackendServer
// for forward compatibility.
//
// The service definition.
type CNIBackendServer interface {
	AddNetwork(context.Context, *AddNetworkRequest) (*AddNetworkReply, error)
	DelNetwork(context.Context, *DelNetworkRequest) (*DelNetworkReply, error)
	GetAllocatableValues(context.Context, *emptypb.Empty) (*GetAllocatableValuesReply, error)
	mustEmbedUnimplementedCNIBackendServer()
}

// UnimplementedCNIBackendServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCNIBackendServer struct{}

func (UnimplementedCNIBackendServer) AddNetwork(context.Context, *AddNetworkRequest) (*AddNetworkReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNetwork not implemented")
}
func (UnimplementedCNIBackendServer) DelNetwork(context.Context, *DelNetworkRequest) (*DelNetworkReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelNetwork not implemented")
}
func (UnimplementedCNIBackendServer) GetAllocatableValues(context.Context, *emptypb.Empty) (*GetAllocatableValuesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllocatableValues not implemented")
}
func (UnimplementedCNIBackendServer) mustEmbedUnimplementedCNIBackendServer() {}
func (UnimplementedCNIBackendServer) testEmbeddedByValue()                    {}

// UnsafeCNIBackendServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CNIBackendServer will
// result in compilation errors.
type UnsafeCNIBackendServer interface {
	mustEmbedUnimplementedCNIBackendServer()
}

func RegisterCNIBackendServer(s grpc.ServiceRegistrar, srv CNIBackendServer) {
	// If the following call pancis, it indicates UnimplementedCNIBackendServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CNIBackend_ServiceDesc, srv)
}

func _CNIBackend_AddNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CNIBackendServer).AddNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CNIBackend_AddNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CNIBackendServer).AddNetwork(ctx, req.(*AddNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CNIBackend_DelNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CNIBackendServer).DelNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CNIBackend_DelNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CNIBackendServer).DelNetwork(ctx, req.(*DelNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CNIBackend_GetAllocatableValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CNIBackendServer).GetAllocatableValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CNIBackend_GetAllocatableValues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CNIBackendServer).GetAllocatableValues(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CNIBackend_ServiceDesc is the grpc.ServiceDesc for CNIBackend service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CNIBackend_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.CNIBackend",
	HandlerType: (*CNIBackendServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddNetwork",
			Handler:    _CNIBackend_AddNetwork_Handler,
		},
		{
			MethodName: "DelNetwork",
			Handler:    _CNIBackend_DelNetwork_Handler,
		},
		{
			MethodName: "GetAllocatableValues",
			Handler:    _CNIBackend_GetAllocatableValues_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/rpc.proto",
}

const (
	NPBackend_EnforceNpToPod_FullMethodName = "/rpc.NPBackend/EnforceNpToPod"
	NPBackend_DeletePodNp_FullMethodName    = "/rpc.NPBackend/DeletePodNp"
)

// NPBackendClient is the client API for NPBackend service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The service definition.
type NPBackendClient interface {
	EnforceNpToPod(ctx context.Context, in *EnforceNpRequest, opts ...grpc.CallOption) (*EnforceNpReply, error)
	DeletePodNp(ctx context.Context, in *DeleteNpRequest, opts ...grpc.CallOption) (*DeleteNpReply, error)
}

type nPBackendClient struct {
	cc grpc.ClientConnInterface
}

func NewNPBackendClient(cc grpc.ClientConnInterface) NPBackendClient {
	return &nPBackendClient{cc}
}

func (c *nPBackendClient) EnforceNpToPod(ctx context.Context, in *EnforceNpRequest, opts ...grpc.CallOption) (*EnforceNpReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnforceNpReply)
	err := c.cc.Invoke(ctx, NPBackend_EnforceNpToPod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nPBackendClient) DeletePodNp(ctx context.Context, in *DeleteNpRequest, opts ...grpc.CallOption) (*DeleteNpReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteNpReply)
	err := c.cc.Invoke(ctx, NPBackend_DeletePodNp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NPBackendServer is the server API for NPBackend service.
// All implementations must embed UnimplementedNPBackendServer
// for forward compatibility.
//
// The service definition.
type NPBackendServer interface {
	EnforceNpToPod(context.Context, *EnforceNpRequest) (*EnforceNpReply, error)
	DeletePodNp(context.Context, *DeleteNpRequest) (*DeleteNpReply, error)
	mustEmbedUnimplementedNPBackendServer()
}

// UnimplementedNPBackendServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNPBackendServer struct{}

func (UnimplementedNPBackendServer) EnforceNpToPod(context.Context, *EnforceNpRequest) (*EnforceNpReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnforceNpToPod not implemented")
}
func (UnimplementedNPBackendServer) DeletePodNp(context.Context, *DeleteNpRequest) (*DeleteNpReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePodNp not implemented")
}
func (UnimplementedNPBackendServer) mustEmbedUnimplementedNPBackendServer() {}
func (UnimplementedNPBackendServer) testEmbeddedByValue()                   {}

// UnsafeNPBackendServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NPBackendServer will
// result in compilation errors.
type UnsafeNPBackendServer interface {
	mustEmbedUnimplementedNPBackendServer()
}

func RegisterNPBackendServer(s grpc.ServiceRegistrar, srv NPBackendServer) {
	// If the following call pancis, it indicates UnimplementedNPBackendServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NPBackend_ServiceDesc, srv)
}

func _NPBackend_EnforceNpToPod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnforceNpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NPBackendServer).EnforceNpToPod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NPBackend_EnforceNpToPod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NPBackendServer).EnforceNpToPod(ctx, req.(*EnforceNpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NPBackend_DeletePodNp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NPBackendServer).DeletePodNp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NPBackend_DeletePodNp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NPBackendServer).DeletePodNp(ctx, req.(*DeleteNpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NPBackend_ServiceDesc is the grpc.ServiceDesc for NPBackend service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NPBackend_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.NPBackend",
	HandlerType: (*NPBackendServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnforceNpToPod",
			Handler:    _NPBackend_EnforceNpToPod_Handler,
		},
		{
			MethodName: "DeletePodNp",
			Handler:    _NPBackend_DeletePodNp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/rpc.proto",
}

const (
	ConfigServerBackend_GetNetworkPolicyConfigs_FullMethodName = "/rpc.ConfigServerBackend/GetNetworkPolicyConfigs"
)

// ConfigServerBackendClient is the client API for ConfigServerBackend service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The service definition.
type ConfigServerBackendClient interface {
	GetNetworkPolicyConfigs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NetworkPolicyAgentConfigReply, error)
}

type configServerBackendClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigServerBackendClient(cc grpc.ClientConnInterface) ConfigServerBackendClient {
	return &configServerBackendClient{cc}
}

func (c *configServerBackendClient) GetNetworkPolicyConfigs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NetworkPolicyAgentConfigReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkPolicyAgentConfigReply)
	err := c.cc.Invoke(ctx, ConfigServerBackend_GetNetworkPolicyConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigServerBackendServer is the server API for ConfigServerBackend service.
// All implementations must embed UnimplementedConfigServerBackendServer
// for forward compatibility.
//
// The service definition.
type ConfigServerBackendServer interface {
	GetNetworkPolicyConfigs(context.Context, *emptypb.Empty) (*NetworkPolicyAgentConfigReply, error)
	mustEmbedUnimplementedConfigServerBackendServer()
}

// UnimplementedConfigServerBackendServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConfigServerBackendServer struct{}

func (UnimplementedConfigServerBackendServer) GetNetworkPolicyConfigs(context.Context, *emptypb.Empty) (*NetworkPolicyAgentConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkPolicyConfigs not implemented")
}
func (UnimplementedConfigServerBackendServer) mustEmbedUnimplementedConfigServerBackendServer() {}
func (UnimplementedConfigServerBackendServer) testEmbeddedByValue()                             {}

// UnsafeConfigServerBackendServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServerBackendServer will
// result in compilation errors.
type UnsafeConfigServerBackendServer interface {
	mustEmbedUnimplementedConfigServerBackendServer()
}

func RegisterConfigServerBackendServer(s grpc.ServiceRegistrar, srv ConfigServerBackendServer) {
	// If the following call pancis, it indicates UnimplementedConfigServerBackendServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConfigServerBackend_ServiceDesc, srv)
}

func _ConfigServerBackend_GetNetworkPolicyConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServerBackendServer).GetNetworkPolicyConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigServerBackend_GetNetworkPolicyConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServerBackendServer).GetNetworkPolicyConfigs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigServerBackend_ServiceDesc is the grpc.ServiceDesc for ConfigServerBackend service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigServerBackend_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ConfigServerBackend",
	HandlerType: (*ConfigServerBackendServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNetworkPolicyConfigs",
			Handler:    _ConfigServerBackend_GetNetworkPolicyConfigs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/rpc.proto",
}
